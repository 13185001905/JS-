
GIT基础知识

什么是git
    分布式版本控制系统，它是由Linux(全球比较大的服务器系统)创始人花两周时间使用C语言编写的工具(在GIT命令窗口中，一般都执行Linux命令)

版本控制系统的优势：
    1.备份文件
    2.记录历史(最大目的)
    3.回到过去
    4.多端共享
    5.团队协作

常用的版本控制系统：
    - git：分布式版本控制系统
    - svn：集中式版本控制系统

分布式和集中式的区别：
    - 集中式：
        + 想要做历史记录的查看或者备份，必须链接到中央服务器才可以使用(需要联网)
        + 处理速度没有git快
        + 安全系数不高
    - 分布式：
        + 每个开发者本地都是一个单独的仓库，在自己的仓库中就可以完成历史版本的记录和查看(不需要联网)
        + git处理的速度更快(git是按照数据存储的)
        + 安全系数高


Linux操作系统中常用的命令：
    Linux          windows
     ls              dir          查看当前目录下的文件(文件夹)
       -l 查看详细信息
       -a 查看隐藏文件
       -la 同时具备以上特定
     clear           cls          清屏
     cd              cd           目录切换
     mkdir           md           创建文件夹
     touch         copy nul       创建空文件
     vi                           向指定文件中插入内容 例如：vi 1.txt
                                      首先进入命令窗口模式
                                      我们先按i，进入插入内容模式
                                      编辑需要写入的内容
                                      按ESC键(退出插入模式)，再按:键，再按wq(保存并退出)
                                      再按q!(强制退出，新输入的内容不保存)
echo xxx > 1.txt                  把xxx内容放到1.txt文件中，如果没有这个文件则会创建这个文件
                                  (新存放的内容会替换原有内容)
echo xxx >> 1.txt                 新的内容会追加到原有内容的后面
     cat                          查看文件中的内容
     cy              copy         拷贝文件
     rm                           删除文件
       -r 递归删除(把当前文件夹中所有的后代元素也遍历删除)
       -f 强制删除
       -rf 一旦rf后，没有办法还原回来，所以删除要慎重


GIT工作原理和流程

安装完成git后，我们最好先把一些基础信息配置一下(只需配置一次即可)

基础配置命令
    $ git config -l / $ git config --list 查看当前本机git的配置清单
    [相对比较重要的配置：user.name/user.email，每一次提交的时候我们知道是谁提交的]
    $ git config --global user.name "用户名"
    $ git config --global user.email "邮箱"
      设置的用户名和邮箱可以随意写，但建议最好写gitHub等平台的账号和邮箱

Git的工作流程：

    git是分布式版本管理系统，每一台客户端都是一个独立的git仓库(有git工作的全套机制)

一个git仓库分为三个区域：
    1.工作区：平时写代码的地方
    2.暂存区：把一些写好暂时存储的地方
         特点:过渡的作用，避免误操作，保护工作区和历史区，分支处理
    3.历史区：生成一个一个版本记录的地方

1.创建GIT仓库
    在指定目录中，执行$ git init，相当于以当前目录为基础，创建了一个本地git仓库
    创建完成后，会在项目的根目录中展示 .git 这个文件(隐藏文件)：有这个 .git文件才叫做git仓库，因为暂存区和历史区的内容都是存储在这个文件夹中的

    删除git仓库
        rm -rf .git

2.把工作区的内容提交到暂存区
    $ git add "文件名" 把某个文件提交到暂存区
    $ git add . 把所有修改的文件(修改和新增的包含，删除的不包含)
    $ git add -u 把所有修改的文件(包含修改和删除的，但是不包含新增的)
    $ git add -A 是点和U的结合体，所有修改，新增，删除的信息都会提交到暂存区(但是真实效果中两个效果差不多，用哪个都行)
    $ git status 查看当前文件的状态
        红色：在工作区中，还没提交到暂存区
        绿色：在暂存区中，还没提交到历史区

    如果提交内容的时候，有些内容并不能提交，我们可以增加git提交的忽略文件：.gitignore(没有文件名，只有后缀名)

    .gitignore中的信息
        .idea 使用WB打开项目或编辑项目，自动生成的文件
        node_modules 使用npm安装模块时，当前安装在项目中的模块都在这个文件夹中(之所以忽略提交是因为这里的内容太多了)
        .DS_Store
        ...

3.把暂存区内容提交到历史区
    $ git commit
    $ git commit -m "注释内容"

    $ git commit -a -m "注释内容" 把提交到暂存区和提交到历史区的步骤合在一起完成(这种方式只适合已经提交过一次的文件，被修改后，我们可以这样快速提交；对于新增加的文件，一次没有提交过，不允许这样操作)
    [root-commit] 根提交
        简单理解为：第一次提交到历史区域，如果我们创建一个新仓库，但是没有做过根提交，此时我们仓库中没有任何的分支(哪怕是master)，也就不存在所谓的分支切换(当前仓库还不完整：一个工作流程走完一遍才算完整)

工作中一些细节知识
    不管是从工作区提交到暂存区，还是从暂存区提交到历史区，每一个区域当前的内容是一直保存下来的，不会消失

4.查看历史区提交记录(历史版本号)
    $ git rm --cached . -r 从暂存区撤回所有文件 (可以把点替换为具体的文件名)  很少使用
                           不管暂存区中的内容是否已经提交到历史版本上，也不管第几次放到暂存区
    $ git log 在没有历史回退的时候查看版本号(有历史回退时，不正常) [--pretty=oneline]
    $ git reflog 在有历史回退的时候查看版本号(有没有历史回退都可以查看)

5.版本回退操作
    $ git checkout . 把暂存区内容回退到工作区(一旦回退，工作区内容无法恢复) 可以理解为：用上一个暂存区存储的内容覆盖现有工作区中的内容，工作区内容变为和上一个暂存区一样的内容，暂存区内容还在   问题：只能限制当前代码还没提交的情况，当前代码没提交回退的是上一次提交到暂存区的内容(和工作区内容不一样)；如果当前这次也提交了，暂存区和工作区一样，回退也是一样的，就解决不了了
     解决：在暂存区中，回退到上一次暂存区中记录的内容(暂存区先退回一次)
    $ git reset HEAD . 把当前暂存区的内容回退到上一个暂存区，目的是为了把上一个暂存区内容回退到工作区
    $ git reset --hard 版本号 在历史区中回退到某一个版本(强制把暂存区和工作区都变成回退后的版本)   最重要的一个回滚技巧   回滚版本号不用全部截取，截取7-8位即可
    $ git reset --hard HEAD^ 回退上一个版本(有几个 ^ 就回退几个版本)
    $ git reset --hard HEAD~n 回退n个版本
    $ history > xxx.txt 把历史操作步骤输出

6.查看每个区代码区别    我们一般都是基于可视化的页面来查看不一样的
    $ git diff 工作区VS暂存区
    $ git diff master 工作区VS历史区MASTER分支
    $ git diff --cached 暂存区VS历史区



团队协作模式的git操作
    每个人是一个单独的本地仓库，有一个中央仓库，用来汇总所有开发者的编码信息(中央仓库一般有LEADER创建，而且最先创建)

1.创建中央仓库
    一般是由团队技术LEADER或者指派的人完成的，仓库中默认是有一些初始化文件的
    中央仓库可能在：gitHub、Coding、自己公司的git仓库服务平台、自己公司的服务器等
    基于gitHub创建远程仓库，创建完成后会生成一个远程地址，例如：https://github.com/573555544/gitTest.git


2.作为LEADER，还需要把项目中一些基础信息提交到远程仓库中
    在自己本地创建一个仓库，把一些基础内容都放在仓库中
    把新增的信息提交到本地仓库历史区中
    让本地仓库和远程仓库保持关联
        $ git remote add 名字(一般叫做origin) 远程仓库地址
        $ git remote rm 名字    移除关联
        $ git remote -v         查看当前仓库和哪些仓库保持关联
        ...
    把本地仓库历史区中的信息同步(推送)到远程仓库中
        $ git push 名字(origin) master 把本地信息推送到远程仓库
        $ git push -u 名字(origin) master 
        $ git pull 名字(origin) master 把远程的拉取到本地
            master是远程仓库的主分支

    当我们创建完远程仓库后，可以直接通过$ git clone 仓库地址 (仓库别名 可不写) 的方式把远程仓库克隆到本地：
        相当于在本地创建了一个仓库
        也让本地仓库和远程仓库保持了连接(名字：origin)
        也把远程仓库中现有的内容克隆到了本地

团队成员克隆到本地，形成本地仓库(LEADER也可以在远程中增加团队成员的管理权限)

主分支master管理模式(用的比较多)
    1.所有人使用的都是master分支，每天上班的第一件事，以及没有提交自己代码的时候，第一件事就是先拉取(PULL)
      $ git pull origin master
      $ git add . /git commit -m"" /git push origin master
    2.如果文件发生冲突，有两种情况：
        a.如果远程仓库和本地仓库不是同一个文件同一行代码冲突：
            git会自动依赖于 Fast-forward 模式进行合并
            自动合并后，我们重新提交即可
            $ git add / commit /push
        b.同一个文件的同一行代码冲突：
            找到冲突的文件，留下自己想要的代码
            不管之前是否commit过，都要重新commit，然后push即可



单独分支管理模式
    1.每天第一件事是把远程master内容拉取到本地master上(提交之前也是)，每个人在自己本地仓库中，先进行分支创建和切换
        $ git branch 查看当前存在的分支
            * master *代表当前在master分支上
        $ git branch dev 创建一个叫dev的分支(当切换到dev分支上时，会把当前MASTER分支中的新信息同步到这个分支上)
        $ git checkout dev 切换到dev分支上
        $ git checkout -b dev 创建并且切换到这个分支
    2.正常的开发和提交，但是所有的操作都是在自己的分支上
    3.把自己本地分支中的内容，合并到自己本地master分支上
        $ git stash 暂存文件(分支有更改，不能直接切换分支，需要把修改的内容暂存)
        先切换到master的分支上
        $ git stash pop 还原暂时存储的内容，
        $ git merge dev 把dev分支合并到master分支上(有冲突按照之前的规则修改)
    4.删除本地创建的分支(可以不删除，但是有的公司不希望远程中出现分支，或者避免开发人员的分支冲突，提交之前都要把自己创建的分支删除)
        1)下一次重新创建分支时候可以让分支和MASTER统一
        2)远程仓库中不记录任何的分支信息，防止冲突
        $ git branch -D dev 删除dev分支(删除的时候需要先切换到其他分支才可以删除)
        $ git log --graph / --oneline 在有分支的情况下，可以更清楚查看分支的提交和合并内容(了解即可，一般不用)   两个都有也可以
    5.将本地master分支中的内容提交到远程仓库中


gitHub界面操作

给别的仓库提交代码修改或者建议
    1.首先FORK别人仓库
        把别人的仓库克隆一份一模一样的，放到自己的账号下，变成自己的仓库(我们平时可以修改自己仓库中的源码)
        FORK的仓库和别人原始仓库会默认建立一些关系，我们可以把自己仓库中和别人仓库不一样的地方，提交给别人(pull-request)

    2.把自己FORK的仓库，克隆到本地
        以后有一些新的代码心得，可以自己尝试去修改，然后同步到自己的FORK仓库中

    3.在gitHub中发送 new pull request


基于gitHub发布静态资源网站(非后台项目)
    gitHub只提供了web站点的发布，后台项目没有提供必要的环境

    [把整个仓库作为一个项目发布]
        这种方式不常用，最简单

    [MASTER是项目代码 gh-pages分支下存储的是项目预览页面的代码]
        其他人克隆研究的是master分支下的代码
        看介绍页面的是gh-pages分支下的代码
       1.创建一个仓库
       2.把仓库克隆到本地
       3.把源码传到master分支上
       4.把本地仓库中创建gh-pages分支
       5.把介绍页面放在gh-pages分支下
       6.把介绍页面的内容上传到gitHub的gh-pages分支下
         访问页面：https://用户名.github.io/仓库名/页面名.html(如果页面是index可以忽略不写)


