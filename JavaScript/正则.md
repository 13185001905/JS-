# 正则

#### match 返回一个数组

```javasc
'[asdf]'.match(/\[\S*\]/g) 
// ["[asdf]"]
```

#### test 返回布尔值

```javasc
/\[\S*\]/g.test('[asdf]') 
// true
```

#### exec 返回处理后的数组

```javas
// 例子1
var  regexp = /\[(.*?)\]/g;
regexp.exec('[asdf]')
// ["[asdf]", "asdf", index: 0, input: "[asdf]", groups: undefined]
```

```javas
/\[(.*?)\]/g.exec('label[placeholder|tip]')
// ["[placeholder|tip]", "placeholder|tip", index: 5, input: "label[placeholder|tip]", groups: undefined]
```

## 入门

```
\b 只匹配一个位置 匹配一个单词边界，也就是指单词和空格间的位置
	\bhi\b   匹配 hi
.  匹配除换行符'\n'外的任何单个字符
*  匹配前面的子表达式零次或多次 eg: .*连在一起就匹配任意数量的不包含换行的字符
\d 匹配一个数字字符。等价于[0-9]
{n} 匹配确定的n次
\w	匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”
+	匹配前面的子表达式一次或多次
{n,m} 最少匹配n次且最多匹配m次
$	匹配输入字符串的结束位置
\ 	转义字符
[xyz]  字符集合。匹配所包含的任意一个字符
?	匹配前面的子表达式零次或一次
^ 	匹配输入字符串的开始位置
[^xyz] 负值字符集合。匹配不包含x,y,z的任意字符 eg: [^abc]可以匹配plain中的p。
\s	匹配任何空白字符: 空格、制表符、换页符
\w	匹配字母(包括大小写)、数字、下划线
```

### 反义

```
\W	匹配任意不是字母，数字，下划线，汉字的字符
\S	匹配任意不是空白符的字符
\D	匹配任意非数字的字符
\B	匹配不是单词开头或结束的位置
[^x]	匹配除了x以外的任意字符
[^aeiou]	匹配除了aeiou这几个字母以外的任意字符

```

### 进阶

```
(pattern) 匹配pattern并获取这一匹配，要匹配圆括号字符，请使用“\(”或“\)”。
(?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配
	eg: “industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。
**************************华丽的分割线*********************************
(?=pattern) 正向肯定预查,在任何匹配pattern的字符串开始处匹配查找字符串
	eg: “Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”
(?<=pattern) 反向肯定预查
	eg: “(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。
**************************华丽的分割线*********************************
(?!pattern)  正向否定预查.
	eg: Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”
(?<!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反
	eg: (?<!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。
	
```

#### 例子

```javas
0\d\d-\d\d\d\d\d\d\d\d
	匹配以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码)
0\d{2}-\d{8} 
	这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。
\ba\w*\b
	匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)
\d+
	匹配1个或更多连续的数字
\b\w{6}\b 
	匹配刚好6个字符的单词
^\d{5,12}$
	匹配QQ号必须为5位到12位的数字,这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。
deerchao\.net  匹配 deerchao.net
C:\\Windows		匹配C:\Windows
^\w+ 
	匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)
[aeiou] 匹配任何一个英文元音字母
[.?!]	 	匹配标点符号(.或?或!)
[0-9] 	与\d就是完全一致的
[a-z0-9A-Z_] 完全等同于\w（如果只考虑英文的话）。
\(?0\d{2}[) -]?\d{8}
	匹配几种格式的电话号码,像(010)88886666,022-22334455,02912345678,但是有bug
\S+ 匹配不包含空白符的字符串
<a[^>]+> 匹配用尖括号括起来的以a开头的字符串。
```

##### 分枝条件

```javas
0\d{2}-\d{8}|0\d{3}-\d{7}
	匹配两种以连字号分隔的电话号码：
		一种是三位区号，8位本地号(如010-12345678)
		一种是4位区号，7位本地号(0376-2233445)
\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}
	匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔
```

##### 分组

```javas
(\d{1,3}\.){3}\d{1,3} 简单的IP地址匹配表达式
	理解： \d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。
	缺点: 它也将匹配256.300.888.999这种不可能存在的IP地址(IP地址中每个数字都不能大于255, 01.02.03.04 这样前面带有0的数字,也是正确的,IP 地址里的数字可以包含有前导 0 )
	解决: 
		((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
```

#### 后向引用

​	使用小括号指定一个子表达式后，**匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推

​	后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本

```javasc
\b(\w+)\b\s+\1\b	可以用来匹配重复的单词，像go go, 或者kitty kitty
	分析: 
	这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，
	这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，
	最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)
```

### 零宽断言

 (?=exp) 零宽度正预测先行断言,它断言自身出现的位置的后面能匹配表达式exp

```
1. \b\w+(?=ing\b) 匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc
```

(?<=exp)也叫零宽度正回顾后发断言,它断言自身出现的位置的前面能匹配表达式exp

```
1. 比如(?<=\bre)\w+\b 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
2. 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?<=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。
3. (?<=\s)\d+(?=\s) 匹配以空白符间隔的数字(再次强调，不包括这些空白符)
```

### 负向零宽断言

**确保某个字符没有出现，但并不想去匹配**

```
\b\wqu\w\b	匹配包含后面不是字母u的字母q的单词
	有bug: 如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符
	解决: 零宽度负预测先行断言
```

##### 零宽度负预测先行断言(?!exp)

断言此位置的后面不能匹配表达式exp

```
\d{3}(?!\d)	匹配三位数字，而且这三位数字的后面不能是数字；
\b((?!abc)\w)+\b	匹配不包含连续字符串abc的单词。
```

##### 零宽度负回顾后发断言(?<!exp)

断言此位置的前面不能匹配表达式exp

```
1. (?<![a-z])\d{7}	 匹配前面不是小写字母的七位数字。
2. (?<=<(\w+)>).*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容。
	分析: (?<=<(\w+)>)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个后缀(?=<\/\1>)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。
	请详细分析表达式(?<=<(\w+)>).*(?=<\/\1>)，这个表达式最能表现零宽断言的真正用途。
```

### 贪婪模式

```
aabab
	a.*b，它将会匹配最长的以a开始，以b结束的字符串,匹配 aabab
	a.*?b 匹配aab（第一到第三个字符）和ab（第四到第五个字符）
```

##### 懒惰限定符

```
*?	重复任意次，但尽可能少重复
+?	重复1次或更多次，但尽可能少重复
??	重复0次或1次，但尽可能少重复
{n,m}?	重复n到m次，但尽可能少重复
{n,}?	重复n次以上，但尽可能少重复
```

### 平衡组/递归匹配

​	匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\(.+\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)

​	为了避免(和\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx <aa <bbb> <bbb> aa> yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？

#### 语法构造

- (?'group') 把捕获的内容命名为group,并压入堆栈(Stack)
- (?'-group') 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
- (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

```
我们需要做的是每碰到了左括号，就在压入一个"Open",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。

<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败

>                         #最外层的右括号
```

```
平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：<div>><>(((?'Open'<div>>)<>)+((?'-Open'</div>)<>)+)(?(Open)(?!))</div>
```

### 参考文档

[正则表达式入门教程](http://www.jb51.net/tools/zhengze.html)

[正则表达式手册](http://tool.oschina.net/uploads/apidocs/jquery/regexp.html)

[关于正则表达式语言元素的MSDN在线文档](https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference)



